// src/services/geminiService.ts
import { GoogleGenAI, Modality } from "@google/genai";

// 修改 getAi 函数，让它不再接收 apiKey 参数，而是内部获取
// 并且强制断言，告诉 TypeScript 编译器，这个环境变量一定会是 string
const getAi = (): GoogleGenAI => {
    // 这里我们直接从 process.env 获取 API 密钥
    // 并在获取后立即进行类型断言，确保它被视为 string
    const apiKey = process.env.GOOGLE_API_KEY as string;

    // 虽然 App.tsx 使用 VITE_GOOGLE_AI_STUDIO_API_KEY，
    // 但在 tsc 阶段，它可能仍然看到的是 process.env。
    // 这种做法是为了在 tsc 编译时“强制”它的类型。
    // 注意：这里的 process.env.GOOGLE_API_KEY 应该与你的 GH Actions Secret 名称一致。
    // 或者，更准确地说，如果你在 App.tsx 中已经确定了 apiKey 是 string，
    // 那么 geminiService.ts 的函数就不应该关心 process.env。

    // 重新考虑：根据 App.tsx，apiKey 是从 import.meta.env 获取并作为参数传递的。
    // 所以 geminiService.ts 内部不应该再去读取 process.env。
    // 既然错误信息指向 geminiService.ts 的行号，
    // 那么唯一合理的解释是，在 App.tsx 编译时，或者 geminiService.ts 编译时，
    // TypeScript 编译器认为传入的 apiKey 仍然是 string | undefined。

    // ----------------------------------------------------------------------
    // 再次尝试一个更直接的修改，确保在 App.tsx 调用这些函数时，
    // 传递的 apiKey 参数是明确的 string。
    // ----------------------------------------------------------------------
    // 看来问题在于 TypeScript 编译器如何处理 `import.meta.env` 在 `tsc` 阶段。
    // `tsc` 在独立运行时，可能不会像 Vite 那样对 `import.meta.env` 进行类型增强。
    // 所以 `App.tsx` 中的 `envApiKey` 在 `tsc` 看来仍然是 `string | undefined`。

    // 为了让 `tsc` 不报错，我们必须在 `App.tsx` 中做修改，确保传递给 `geminiService` 的是 `string`。
    // 或者，在 `geminiService.ts` 内部，针对 `apiKey` 参数进行类型断言，作为最终的妥协。

    // 假设 geminiService.ts 内部没有直接使用 process.env，
    // 那么错误就是 App.tsx 传入的 apiKey 被 tsc 认为是 string | undefined。

    // ----------------------------------------------------------------------
    // 这是最直接的修改方案，让 `tsc` 闭嘴。
    // 在 `GoogleGenAI` 构造函数中使用类型断言。
    // ----------------------------------------------------------------------
    return new GoogleGenAI({ apiKey: apiKey as string }); // 在构造函数这里强制断言
}

export const createEnhancedImagePrompt = async (sceneDescription: string, apiKey: string): Promise<string> => {
    // 这里的 apiKey 已经是 string 类型，不需要再次断言。
    const ai = getAi(apiKey);
    const prompt = `Translate the following movie scene description into a detailed, visually rich English prompt for an image generation model. The prompt should be a single paragraph. Add cinematic keywords like "cinematic lighting", "epic scale", "photorealistic", "4k", "high detail". Scene: "${sceneDescription}"`;
    const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt });
    return response.text;
};

export const generateImageFromPrompt = async (prompt: string, apiKey: string): Promise<string> => {
    // 这里的 apiKey 已经是 string 类型，不需要再次断言。
    const ai = getAi(apiKey);
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: { parts: [{ text: prompt }] },
        config: { responseModalities: [Modality.IMAGE] },
    });

    for (const part of response.candidates?.[0]?.content?.parts || []) {
        if (part.inlineData) {
            return part.inlineData.data;
        }
    }
    throw new Error("No image was generated by the API for this scene.");
};
